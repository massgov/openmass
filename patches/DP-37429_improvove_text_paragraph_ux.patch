diff --git a/css/builder.css b/css/builder.css
index e01d327..809ebf2 100644
--- a/css/builder.css
+++ b/css/builder.css
@@ -46,7 +46,7 @@
   outline: 3px solid blue;
 }
 .js-lpb-component {
-  cursor: grab;
+  cursor: default;
 }
 .js-lpb-component:hover .js-lpb-region,
 .js-lpb-component:focus-within .js-lpb-region {
@@ -421,3 +421,8 @@ a.lpb-enable-button::before {
 .ck.ck-balloon-panel.ck-balloon-panel_visible {
   z-index: 1500;
 }
+
+.js-lpb-component[data-type="rich_text"] {
+  cursor: text;
+}
+
diff --git a/js/builder.js b/js/builder.js
index 7ad5c72..c8d2854 100644
--- a/js/builder.js
+++ b/js/builder.js
@@ -316,7 +316,7 @@
         null,
         $item.next().length ? $item.next()[0] : null,
       ).length > 0
-    ) {
+      ) {
       pos += dir;
     }
     if (targets[pos + dir] !== undefined) {
@@ -458,27 +458,27 @@
     containers.forEach((container) => {
       Sortable.create(container, {
         group: 'shared',
-          draggable: '.js-lpb-component',
-          handle: '.lpb-drag',
-          animation: 150,
-          onStart: (evt) => {
+        draggable: '.js-lpb-component',
+        handle: '.lpb-drag',
+        animation: 150,
+        onStart: (evt) => {
           const $el = $(evt.item);
           $el.addClass('is-dragging');
           $element.addClass('is-dragging');
           $element.trigger('lpb-component:drag', [$el.attr('data-uuid')]);
-          },
-          onEnd: (evt) => {
+        },
+        onEnd: (evt) => {
           const $el = $(evt.item);
           $el.removeClass('is-dragging');
           $element.removeClass('is-dragging');
           reorderComponents($element); // Trigger reordering logic.
-            $element.trigger('lpb-component:drop', [$el.attr('data-uuid')]);
-            },
-          onMove: (evt) => {
+          $element.trigger('lpb-component:drop', [$el.attr('data-uuid')]);
+        },
+        onMove: (evt) => {
           // Validate move using acceptsErrors (if applicable).
-            const errors = acceptsErrors(settings, evt.dragged, evt.to, evt.from, evt.related);
-            return errors.length === 0; // Allow move only if no errors.
-          },
+          const errors = acceptsErrors(settings, evt.dragged, evt.to, evt.from, evt.related);
+          return errors.length === 0; // Allow move only if no errors.
+        },
       });
     });
   }
@@ -595,8 +595,8 @@
           if (e.type === 'lpb-component:update') {
             if (triggerElement) {
               window.scrollTo({
-                  top: scrollPosition,
-                  behavior: 'auto',
+                top: scrollPosition,
+                behavior: 'auto',
               });
             }
           }
@@ -629,33 +629,33 @@
           // Dynamically add the container to the existing Sortable instance.
           Sortable.create(container, {
             group: sortableInstance.options.group,
-              draggable: '.js-lpb-component',
-              handle: '.lpb-drag',
-              animation: 150,
-              onStart: (evt) => {
+            draggable: '.js-lpb-component',
+            handle: '.lpb-drag',
+            animation: 150,
+            onStart: (evt) => {
               const $el = $(evt.item);
               $el.addClass('is-dragging');
               $builderElement.addClass('is-dragging');
               $builderElement.trigger('lpb-component:drag', [$el.attr('data-uuid')]);
-              },
-              onEnd: (evt) => {
+            },
+            onEnd: (evt) => {
               const $el = $(evt.item);
               $el.removeClass('is-dragging');
               $builderElement.removeClass('is-dragging');
               reorderComponents($builderElement); // Trigger reordering logic.
-                $builderElement.trigger('lpb-component:drop', [$el.attr('data-uuid')]);
-                },
-              onMove: (evt) => {
+              $builderElement.trigger('lpb-component:drop', [$el.attr('data-uuid')]);
+            },
+            onMove: (evt) => {
               // Validate move using acceptsErrors (if applicable).
-                const errors = acceptsErrors(
-                  sortableInstance.options.settings,
-                  evt.dragged,
-                  evt.to,
-                  evt.from,
-                  evt.related
-                );
-                return errors.length === 0; // Allow move only if no errors.
-              },
+              const errors = acceptsErrors(
+                sortableInstance.options.settings,
+                evt.dragged,
+                evt.to,
+                evt.from,
+                evt.related
+              );
+              return errors.length === 0; // Allow move only if no errors.
+            },
           });
         } else {
           console.warn('No Sortable instance found for:', $builderElement);
@@ -688,26 +688,195 @@
 
   const handleAfterDialogCreate = (event, dialog, $dialog) => {
     const $element = $dialog || jQuery(event.target);
+
     if ($element.attr('id').startsWith('lpb-dialog-')) {
       updateDialogButtons($element);
+
       if (triggerElement) {
         window.scrollTo({
-            top: scrollPosition,
-            behavior: 'auto',
+          top: scrollPosition,
+          behavior: 'auto',
         });
         triggerElement.focus();
       }
+
       clearInterval(lpDialogInterval);
       lpDialogInterval = setInterval(
         repositionDialog.bind(null, lpDialogInterval),
         500
       );
+
+      // Minimal delay to ensure CKEditor is fully initialized before restoring cursor
+      setTimeout(() => {
+        let editorElement = $element.find('.ck-editor__editable')[0];
+
+        if (editorElement) {
+          let editorInstance = editorElement.ckeditorInstance;
+
+          let parentComponent = $('.js-lpb-component[data-type="rich_text"]').filter(function() {
+            return $(this).data("cursorPosition") !== undefined;
+          }).last();
+
+          if (editorInstance && parentComponent.length) {
+            let charIndex = parentComponent.data("cursorPosition");
+
+            let textBeforeConversion = $("<div>").html(parentComponent.find('.text-formatted').html()).text();
+            let ckText = $("<div>").html(editorInstance.getData()).text();
+            let adjustedCharIndex = adjustCharIndexForHTML(textBeforeConversion, ckText, charIndex);
+
+            setCursorAndScroll(editorElement, adjustedCharIndex);
+          }
+        }
+      }, 200); // ðŸ”¹ Keeping it minimal but ensuring CKEditor is ready
     }
   };
+
+// Attach event listener for when the modal dialog is created.
   if (typeof DrupalDialogEvent === 'undefined') {
     $(window).on('dialog:aftercreate', handleAfterDialogCreate);
   } else {
     window.addEventListener('dialog:aftercreate', handleAfterDialogCreate);
   }
 
+  /**
+   * Click handler: Stores cursor position and triggers the edit button.
+   */
+  $(document).on('click.lp-builder', '.js-lpb-component[data-type="rich_text"]', function (e) {
+    e.preventDefault();
+
+    const component = $(this);
+    const editButton = component.find('.lpb-edit.use-ajax');
+    const textElement = component.find('.text-formatted').get(0);
+
+    $('.js-lpb-component[data-type="rich_text"]').removeData("cursorPosition");
+
+    if (textElement) {
+      const cursorPosition = getCaretCharacterOffsetWithin(textElement);
+      component.data("cursorPosition", cursorPosition);
+    }
+
+    if (editButton.length) {
+      editButton.trigger('click');
+    }
+  });
+
+  /**
+   * Moves the cursor inside CKEditor and ensures proper scrolling.
+   */
+  function setCursorAndScroll(el, charIndex) {
+    if (!el) return;
+
+    let range = document.createRange();
+    let textNodes = getTextNodesIn(el);
+    let charCount = 0;
+    let found = false;
+
+    let totalTextLength = textNodes.reduce((sum, node) => sum + node.length, 0);
+    charIndex = Math.min(charIndex, totalTextLength - 1);
+
+    for (let i = 0; i < textNodes.length; i++) {
+      let textNode = textNodes[i];
+      let endCharCount = charCount + textNode.length;
+
+      if (charIndex >= charCount && charIndex < endCharCount) {
+        range.setStart(textNode, charIndex - charCount);
+        range.collapse(true);
+        found = true;
+        break;
+      }
+      charCount = endCharCount;
+    }
+
+    if (found) {
+      let sel = window.getSelection();
+      sel.removeAllRanges();
+      sel.addRange(range);
+
+      let editorContainer = el.closest(".ck-editor__editable");
+      let modalContent = el.closest(".ui-dialog-content");
+
+      if (modalContent) {
+        let modalRect = modalContent.getBoundingClientRect();
+        let editorRect = editorContainer.getBoundingClientRect();
+        let scrollToY = modalContent.scrollTop + (editorRect.top - modalRect.top) - 50;
+
+        modalContent.scrollTo({
+          top: Math.max(scrollToY, 0),
+          behavior: "smooth",
+        });
+      }
+
+      setTimeout(() => {
+        if (editorContainer) {
+          let containerRect = editorContainer.getBoundingClientRect();
+          let rect = range.getBoundingClientRect();
+          let extraPadding = 80;
+          let targetScrollTop = editorContainer.scrollTop + (rect.top - containerRect.top) - extraPadding;
+          let maxScroll = editorContainer.scrollHeight - editorContainer.clientHeight;
+
+          let lineHeight = parseFloat(window.getComputedStyle(editorContainer).lineHeight) || 20;
+          let remainingLines = (totalTextLength - charIndex) / lineHeight;
+
+          if (remainingLines <= 4) {
+            targetScrollTop = maxScroll;
+          }
+
+          targetScrollTop = Math.min(targetScrollTop, maxScroll);
+          editorContainer.scrollTo({
+            top: Math.max(0, targetScrollTop),
+            behavior: "smooth",
+          });
+        }
+      }, 150); // ðŸ”¹ Small delay to ensure outer modal scrolls first
+    }
+  }
+
+  /**
+   * Retrieves the cursor position inside `.text-formatted`.
+   */
+  function getCaretCharacterOffsetWithin(element) {
+    let range = document.createRange();
+    let selection = window.getSelection();
+
+    if (!selection.rangeCount) return 0;
+
+    range.setStart(element, 0);
+    range.setEnd(selection.anchorNode, selection.anchorOffset);
+
+    return range.toString().length;
+  }
+
+  /**
+   * Adjusts character index due to HTML structure differences.
+   */
+  function adjustCharIndexForHTML(originalText, ckText, charIndex) {
+    let cleanedOriginalText = originalText.replace(/\s+/g, ' ').trim();
+    let cleanedCkText = ckText.replace(/\s+/g, ' ').trim();
+
+    let adjustedIndex = charIndex;
+
+    for (let i = 0, j = 0; i < cleanedOriginalText.length && j < cleanedCkText.length; i++, j++) {
+      if (i === charIndex) return j;
+      while (cleanedOriginalText[i] !== cleanedCkText[j] && j < cleanedCkText.length) j++;
+    }
+
+    return Math.min(adjustedIndex, cleanedCkText.length - 1);
+  }
+
+  /**
+   * Function to get all text nodes inside an element.
+   */
+  function getTextNodesIn(node) {
+    let textNodes = [];
+    if (node.nodeType === 3) {
+      textNodes.push(node);
+    } else {
+      let children = node.childNodes;
+      for (let i = 0; i < children.length; i++) {
+        textNodes.push.apply(textNodes, getTextNodesIn(children[i]));
+      }
+    }
+    return textNodes;
+  }
+
 })(jQuery, Drupal, Drupal.debounce, Sortable, once);
