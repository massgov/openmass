diff --git a/css/builder.css b/css/builder.css
index e01d327..353453c 100644
--- a/css/builder.css
+++ b/css/builder.css
@@ -46,7 +46,7 @@
   outline: 3px solid blue;
 }
 .js-lpb-component {
-  cursor: grab;
+  cursor: default;
 }
 .js-lpb-component:hover .js-lpb-region,
 .js-lpb-component:focus-within .js-lpb-region {
@@ -421,3 +421,17 @@ a.lpb-enable-button::before {
 .ck.ck-balloon-panel.ck-balloon-panel_visible {
   z-index: 1500;
 }
+
+.js-lpb-component[data-type="rich_text"] {
+  cursor: text;
+}
+
+/* Hover cursor for non-rich-text components */
+.js-lpb-component:not([data-type="rich_text"]) {
+  cursor: pointer;
+}
+
+/* Optional: subtle background on hover to reinforce interactivity */
+.lp-builder:not(.is-navigating) .js-lpb-component:not([data-type="rich_text"]):hover {
+  background-color: rgba(0, 0, 255, 0.05);
+}
diff --git a/js/builder.js b/js/builder.js
index 7ad5c72..234825f 100644
--- a/js/builder.js
+++ b/js/builder.js
@@ -688,26 +688,217 @@
 
   const handleAfterDialogCreate = (event, dialog, $dialog) => {
     const $element = $dialog || jQuery(event.target);
+
     if ($element.attr('id').startsWith('lpb-dialog-')) {
       updateDialogButtons($element);
+
       if (triggerElement) {
         window.scrollTo({
-            top: scrollPosition,
-            behavior: 'auto',
+          top: scrollPosition,
+          behavior: 'auto',
         });
         triggerElement.focus();
       }
+
       clearInterval(lpDialogInterval);
       lpDialogInterval = setInterval(
         repositionDialog.bind(null, lpDialogInterval),
         500
       );
+
+      // Minimal delay to ensure CKEditor is fully initialized before restoring cursor
+      setTimeout(() => {
+        let editorElement = $element.find('.ck-editor__editable')[0];
+
+        if (editorElement) {
+          let editorInstance = editorElement.ckeditorInstance;
+
+          let parentComponent = $('.js-lpb-component[data-type="rich_text"]').filter(function() {
+            return $(this).data("cursorPosition") !== undefined;
+          }).last();
+
+          if (editorInstance && parentComponent.length) {
+            let charIndex = parentComponent.data("cursorPosition");
+
+            let textBeforeConversion = $("<div>").html(parentComponent.find('.text-formatted').html()).text();
+            let ckText = $("<div>").html(editorInstance.getData()).text();
+            let adjustedCharIndex = adjustCharIndexForHTML(textBeforeConversion, ckText, charIndex);
+
+            setCursorAndScroll(editorElement, adjustedCharIndex, parentComponent);
+          }
+        }
+      }, 200); // ðŸ”¹ Keeping it minimal but ensuring CKEditor is ready
     }
   };
+
+// Attach event listener for when the modal dialog is created.
   if (typeof DrupalDialogEvent === 'undefined') {
     $(window).on('dialog:aftercreate', handleAfterDialogCreate);
   } else {
     window.addEventListener('dialog:aftercreate', handleAfterDialogCreate);
   }
 
+  /**
+   * Click handler: Stores cursor position and triggers the edit button.
+   */
+  $(document).on('click.lp-builder', '.js-lpb-component[data-type="rich_text"]', function (e) {
+    e.preventDefault();
+
+    const component = $(this);
+    const editButton = component.find('.lpb-edit.use-ajax');
+    const textElement = component.find('.text-formatted').get(0);
+
+    $('.js-lpb-component[data-type="rich_text"]').removeData("cursorPosition");
+
+    if (textElement) {
+      const cursorPosition = getCaretCharacterOffsetWithin(textElement);
+      component.data("cursorPosition", cursorPosition);
+    }
+
+    if (editButton.length) {
+      editButton.trigger('click');
+    }
+  });
+
+  // Generic handler: open other components on background click (no scroll).
+  $(document).on('click.lp-builder', '.js-lpb-component:not([data-type="rich_text"])', function (e) {
+    e.preventDefault();
+
+    const $component = $(this);
+    const $editButton = $component.find('.lpb-edit.use-ajax');
+
+    if ($editButton.length) {
+      // Prevent scroll restoration logic.
+      triggerElement = null;
+      // Remove any old rich_text cursor position.
+      $component.removeData("cursorPosition");
+      // Trigger modal open.
+      $editButton.trigger('click');
+    }
+  });
+
+  /**
+   * Moves the cursor inside CKEditor and ensures proper scrolling.
+   */
+  function setCursorAndScroll(el, charIndex, parentComponent) {
+    if (!el) return;
+
+    let range = document.createRange();
+    let textNodes = getTextNodesIn(el);
+    let charCount = 0;
+    let found = false;
+
+    let totalTextLength = textNodes.reduce((sum, node) => sum + node.length, 0);
+    charIndex = Math.min(charIndex, totalTextLength - 1);
+
+    for (let i = 0; i < textNodes.length; i++) {
+      let textNode = textNodes[i];
+      let endCharCount = charCount + textNode.length;
+
+      if (charIndex >= charCount && charIndex < endCharCount) {
+        range.setStart(textNode, charIndex - charCount);
+        range.collapse(true);
+        found = true;
+        break;
+      }
+      charCount = endCharCount;
+    }
+
+    if (found) {
+      let sel = window.getSelection();
+      sel.removeAllRanges();
+      sel.addRange(range);
+
+      let editorContainer = el.closest(".ck-editor__editable");
+      let modalContent = el.closest(".ui-dialog-content");
+
+      if (modalContent) {
+        let modalRect = modalContent.getBoundingClientRect();
+        let editorRect = editorContainer.getBoundingClientRect();
+        let scrollToY = modalContent.scrollTop + (editorRect.top - modalRect.top) - 50;
+
+        modalContent.scrollTo({
+          top: Math.max(scrollToY, 0),
+          behavior: "smooth",
+        });
+      }
+
+      setTimeout(() => {
+        if (editorContainer) {
+          let containerRect = editorContainer.getBoundingClientRect();
+          let rect = range.getBoundingClientRect();
+          let extraPadding = 80;
+          let targetScrollTop = editorContainer.scrollTop + (rect.top - containerRect.top) - extraPadding;
+          let maxScroll = editorContainer.scrollHeight - editorContainer.clientHeight;
+
+          let lineHeight = parseFloat(window.getComputedStyle(editorContainer).lineHeight) || 20;
+          let remainingLines = (totalTextLength - charIndex) / lineHeight;
+
+          if (remainingLines <= 4) {
+            targetScrollTop = maxScroll;
+          }
+
+          targetScrollTop = Math.min(targetScrollTop, maxScroll);
+          editorContainer.scrollTo({
+            top: Math.max(0, targetScrollTop),
+            behavior: "smooth",
+          });
+
+          // âœ… **Clear the stored cursor position after scroll is complete**
+          if (parentComponent) {
+            parentComponent.removeData("cursorPosition");
+          }
+        }
+      }, 150); // ðŸ”¹ Small delay to ensure outer modal scrolls first
+    }
+  }
+
+  /**
+   * Retrieves the cursor position inside `.text-formatted`.
+   */
+  function getCaretCharacterOffsetWithin(element) {
+    let range = document.createRange();
+    let selection = window.getSelection();
+
+    if (!selection.rangeCount) return 0;
+
+    range.setStart(element, 0);
+    range.setEnd(selection.anchorNode, selection.anchorOffset);
+
+    return range.toString().length;
+  }
+
+  /**
+   * Adjusts character index due to HTML structure differences.
+   */
+  function adjustCharIndexForHTML(originalText, ckText, charIndex) {
+    let cleanedOriginalText = originalText.replace(/\s+/g, ' ').trim();
+    let cleanedCkText = ckText.replace(/\s+/g, ' ').trim();
+
+    let adjustedIndex = charIndex;
+
+    for (let i = 0, j = 0; i < cleanedOriginalText.length && j < cleanedCkText.length; i++, j++) {
+      if (i === charIndex) return j;
+      while (cleanedOriginalText[i] !== cleanedCkText[j] && j < cleanedCkText.length) j++;
+    }
+
+    return Math.min(adjustedIndex, cleanedCkText.length - 1);
+  }
+
+  /**
+   * Function to get all text nodes inside an element.
+   */
+  function getTextNodesIn(node) {
+    let textNodes = [];
+    if (node.nodeType === 3) {
+      textNodes.push(node);
+    } else {
+      let children = node.childNodes;
+      for (let i = 0; i < children.length; i++) {
+        textNodes.push.apply(textNodes, getTextNodesIn(children[i]));
+      }
+    }
+    return textNodes;
+  }
+
 })(jQuery, Drupal, Drupal.debounce, Sortable, once);
