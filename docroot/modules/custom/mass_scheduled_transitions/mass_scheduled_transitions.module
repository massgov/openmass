<?php

use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\TranslatableInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\mass_content_moderation\MassModeration;
use Drupal\node\NodeInterface;
use Drupal\scheduled_transitions\Entity\ScheduledTransition;
use Drupal\workflows\Entity\Workflow;

/**
 * Implements entity_base_field_info_alter().
 */
function mass_scheduled_transitions_entity_base_field_info_alter($fields, EntityTypeInterface $entity_type) {

  if ($entity_type->id() === 'node') {
    $fields['moderation_state']
      ->addConstraint('MassScheduledTransitionsPromoPageUnpublish')
      ->addConstraint('MassScheduledTransitionsAlertUnpublish');
  }
  return $fields;
}

/**
 * Implements hook_ENTITY_TYPE_insert() for node entities.
 * 
 * Automatically create the required scheduled transitions.
 */
function mass_scheduled_transitions_node_insert(NodeInterface $node) {
  if ($node->bundle() == 'alert') {
    $duration = '14 days';
    $workflow = 'editorial';
  }
  elseif ($node->bundle() == 'campaign_landing') {
    $duration = '180 days';
    $workflow = 'campaign_landing_page';
  }
  else {
    // Do nothing
    return;
  }
  /** @var ScheduledTransition $transition */
  $transition = ScheduledTransition::create([]);
  $datetime = (new DrupalDateTime("now + $duration"))->getPhpDateTime();
  $transition->setTransitionDate($datetime)
    ->setAuthor($node->getOwner())
    ->setState(Workflow::load($workflow), MassModeration::UNPUBLISHED)
    ->setEntity($node)
    // 0 means 'latest'
    ->setEntityRevisionId(0)
    ->save();
  $url_edit = $transition->toUrl('reschedule-form')->toString();
  \Drupal::messenger()->addStatus("An unpublish transition has been scheduled for $duration days from today. <a href=\"$url_edit\">Reschedule transition</a>.");
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function mass_scheduled_transitions_menu_local_tasks_alter(&$data, $route_name, &$cacheability) {
  $a=1;
}

/**
 * Populate default value for the time so users don't have to complete the time element.

 * Applies to the add_form.
 *
 * @param $form
 * @param $form_state
 */
function mass_scheduled_transitions_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (strpos($form_id, 'scheduled_transitions_add_form_form')) {
    $form['scheduled_transitions']['new_meta']['on']['#default_value'] = new DrupalDateTime("now +1 day");
  }
}

/**
 * Load a list of scheduled transitions by host entity.
 *
 * A copy of \Drupal\scheduled_transitions\ScheduledTransitionsEntityHooks::loadByHostEntity sicne that is not public+static
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 * @param bool $revision_match
 *   TRUE to match revision too.
 *
 * @return \Drupal\scheduled_transitions\Entity\ScheduledTransitionInterface[]
 *   A list of scheduled transitions for the given entity.
 */
function mass_scheduled_transitions_loadByHostEntity(EntityInterface $entity, bool $revision_match = FALSE): array {
  $transitionStorage = Drupal::entityTypeManager()->getStorage('scheduled_transition');
  $query = $transitionStorage->getQuery()
    ->condition('entity.target_id', $entity->id())
    ->condition('entity.target_type', $entity->getEntityTypeId())
    ->accessCheck(FALSE);
  if ($revision_match) {
    $query->condition('entity_revision_id', $entity->getRevisionId());
  }
  if ($entity instanceof TranslatableInterface && !$entity->isDefaultTranslation()) {
    $query->condition('entity_revision_langcode', $entity->language()->getId());
  }
  $ids = $query->execute();
  return $transitionStorage->loadMultiple($ids);
}