<?php

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Datetime\DrupalDateTime;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Entity\TranslatableInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\mass_content_moderation\MassModeration;
use Drupal\node\NodeInterface;
use Drupal\scheduled_transitions\Entity\ScheduledTransition;
use Drupal\workflows\Entity\Workflow;

define('MASS_SCHEDULED_TRANSITIONS_CAMPAIGN_LANDING_MAX_DURATION', '14 months');
define('MASS_SCHEDULED_TRANSITIONS_ALERT_MAX_DURATION', '6 months');

/**
 * Implements hook_entity_base_field_info_alter().
 */
function mass_scheduled_transitions_entity_base_field_info_alter($fields, EntityTypeInterface $entity_type) {

  if ($entity_type->id() === 'node') {
    $fields['moderation_state']
      ->addConstraint('MassScheduledTransitionsPromoPageUnpublish')
      ->addConstraint('MassScheduledTransitionsAlertUnpublish');
  }
  return $fields;
}

/**
 * Implements hook_entity_type_alter().
 *
 * @param iterable $entity_types
 *
 * @return void
 */
function mass_scheduled_transitions_entity_type_alter(iterable &$entity_types) {
  $entity_types['scheduled_transition']->addConstraint('MassScheduledTransitionsAlertSitewide');
}


/**
 * Implements hook_ENTITY_TYPE_insert() for node entities.
 * 
 * Automatically create the required scheduled transitions.
 */
function mass_scheduled_transitions_node_insert(NodeInterface $node) {
  if ($node->bundle() == 'alert') {
    $duration = '14 days';
    $workflow = 'editorial';
  }
  elseif ($node->bundle() == 'campaign_landing') {
    $duration = '180 days';
    $workflow = 'campaign_landing_page';
  }
  else {
    // Do nothing
    return;
  }
  /** @var ScheduledTransition $transition */
  $transition = ScheduledTransition::create([]);
  $datetime = (new DrupalDateTime("now + $duration"))->getPhpDateTime();
  $transition->setTransitionDate($datetime)
    ->setAuthor($node->getOwner())
    ->setState(Workflow::load($workflow), MassModeration::UNPUBLISHED)
    ->setEntity($node)
    // 0 means 'latest'.
    ->setEntityRevisionId(0)
    ->setOptions([
      [ScheduledTransition::OPTION_RECREATE_NON_DEFAULT_HEAD => TRUE,
       ScheduledTransition::OPTION_LATEST_REVISION => TRUE],
    ])
    ->save();
  $url_edit = $transition->toUrl('reschedule-form')->toString();
  $replacements = [':url_edit' => $url_edit, '@duration' => $duration];
  \Drupal::messenger()->addStatus(t("An unpublish transition has been scheduled for @duration days from today. <a href=\":url_edit\">Reschedule transition</a>.", $replacements));
}

/**
 * Implements hook_ENTITY_TYPE_access().
 *
 * Deny deletion of scheduled transitions when their host entity requires one.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param $operation
 *
 * @return mixed
 */
function mass_scheduled_transitions_scheduled_transition_access(EntityInterface $transition, $operation) {
  $entity = $transition->getEntity();
  if ($operation != 'delete' || !$entity->isPublished() || !in_array($entity->bundle(), ['alert', 'campaign_landing'])) {
    return;
  }

  $duration_string = $entity->bundle() == 'alert' ? MASS_SCHEDULED_TRANSITIONS_ALERT_MAX_DURATION : MASS_SCHEDULED_TRANSITIONS_CAMPAIGN_LANDING_MAX_DURATION;
  $duration = (new DrupalDateTime('now +' . $duration_string))->getTimestamp();
  $transitions = mass_scheduled_transitions_loadByHostEntity($entity);
  unset($transitions[$transition->id()]);
  $fail = TRUE;
  foreach ($transitions as $transition) {
    if ($transition->getState() == MassModeration::UNPUBLISHED && $transition->getTransitionDate()
        ->getTimestamp() < $duration) {
      $fail = FALSE;
    }
  }
  if ($fail) {
    return AccessResult::forbidden('Alerts or promo page requires an imminent unpublish transition');
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function mass_scheduled_transitions_menu_local_tasks_alter(&$data, $route_name, &$cacheability) {
  $a=1;
}

/**
 * Populate default value for the time so users don't have to complete the time element.

 * Applies to the add_form.
 *
 * @param $form
 * @param $form_state
 */
function mass_scheduled_transitions_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (strpos($form_id, 'scheduled_transitions_add_form_form')) {
    $form['scheduled_transitions']['new_meta']['on']['#default_value'] = new DrupalDateTime("now +1 day");
  }
}

/**
 * Load a list of scheduled transitions by host entity.
 *
 * A copy of \Drupal\scheduled_transitions\ScheduledTransitionsEntityHooks::loadByHostEntity sicne that is not public+static
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   Entity.
 * @param bool $revision_match
 *   TRUE to match revision too.
 *
 * @return \Drupal\scheduled_transitions\Entity\ScheduledTransitionInterface[]
 *   A list of scheduled transitions for the given entity.
 */
function mass_scheduled_transitions_loadByHostEntity(EntityInterface $entity, bool $revision_match = FALSE): array {
  $transitionStorage = Drupal::entityTypeManager()->getStorage('scheduled_transition');
  $query = $transitionStorage->getQuery()
    ->condition('entity.target_id', $entity->id())
    ->condition('entity.target_type', $entity->getEntityTypeId())
    ->accessCheck(FALSE);
  if ($revision_match) {
    $query->condition('entity_revision_id', $entity->getRevisionId());
  }
  if ($entity instanceof TranslatableInterface && !$entity->isDefaultTranslation()) {
    $query->condition('entity_revision_langcode', $entity->language()->getId());
  }
  $ids = $query->execute();
  return $transitionStorage->loadMultiple($ids);
}